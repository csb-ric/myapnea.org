# frozen_string_literal: true

class Answer < ApplicationRecord
  # Constants
  STATE = %(incomplete complete migrated locked)

  # Concerns
  include DateAndTimeParser

  # Named Scopes
  scope :incomplete,  -> { where state: 'incomplete' }
  scope :invalid,     -> { where state: 'invalid' }
  scope :migrated,    -> { where state: 'migrated' }
  scope :complete,    -> { where state: ['complete', 'locked'] }
  scope :locked,      -> { where state: 'locked' }

  # Model Validation
  validates_presence_of :answer_session_id, :question_id
  validates_uniqueness_of :question_id, scope: [:answer_session_id]

  # Model Relationships
  has_many :answer_values, dependent: :destroy
  belongs_to :question
  belongs_to :answer_session

  # Model Methods

  ## Value Methods
  ## Different options:
  # It gets complicated with many answer templates
  #   at most basic, one answer template with not allowed multiple ==> target field gets value
  #   then, one answer templates with allowed multiple ==> builds from array of values
  #
  #   we repeat this for all answer templates
  #
  #   the inputs can be single value, array of values, hash with answer templates as keys
  #   if multiple answer templates are present, then hash is NECESSARY

  # single value, raw value!
  # single value, answer option id (multiple_choice)
  # Multiple Values, answer option id (check_box)
  # (not supported now) multiple values,

  def update_response_value!(val)
    # Deal with nil values, generated by empty checkbox questions
    val = {} if val.nil? or not val.is_a?(Hash)

    # Remove, because this process answer already checks for this
    if locked?
      logger.warn "Attempting to change value of locked answer: survey: #{answer_session.survey.slug} | question: #{question.slug} | user: #{answer_session.user.email} | encounter: #{answer_session.encounter}"
      return nil
    end

    self[:preferred_not_to_answer] = (val.delete('preferred_not_to_answer') ? true : false)

    answer_values.clear
    template_completions = []
    template_values = []

    question.answer_templates.unarchived.each do |template|
      target_field = template.data_type

      val_for_template = val[template.id.to_s]

      case template.template_name when 'date'
        month = parse_integer(val_for_template[:month])
        day = parse_integer(val_for_template[:day])
        year = parse_integer(val_for_template[:year])
        val_for_template = parse_date_to_s("#{month}/#{day}/#{year}", "#{month}/#{day}/#{year}")
      when 'height'
        feet = parse_integer(val_for_template[:feet], 0)
        inches = parse_integer(val_for_template[:inches], 0)
        height = (feet * 12 + inches)
        val_for_template = (height > 0 ? height : nil)
      end

      template_values << val_for_template

      # Test for nested inputs. There is a dependency: all conditionals are one-level, and the first answer template in questions with nested inputs is a categorical question that spawns the nesting.
      # TODO: Add Testing
      if template.parent_answer_option_value.present? and template_completions.first
        answer_option_ids = template_values.first.is_a?(Array) ? template_values.first : [template_values.first]
        answer_options = answer_option_ids.map{ |ao_id| AnswerOption.find(ao_id) }
        answer_option_values = answer_options.map(&:value)

        template_completion = answer_option_values.include?(template.parent_answer_option_value) ? val_for_template.present? : true
      else
        template_completion = val_for_template.present?
      end

      template_completions << template_completion

      if template.allow_multiple and val_for_template.is_a?(Array)
        val_for_template.each {|v| answer_values.build(target_field => v, 'answer_template_id' => template.id) }
      else
        answer_values.build(target_field => val_for_template, 'answer_template_id' => template.id)
      end
    end

    set_completion_state(template_completions)

    self.save
  end

  def update_response_value_from_api!(val)

    template = AnswerTemplate.find_by_id(val.keys[0])
    response_value = val.values[0]
    answer_values.where(answer_template_id: template.id).delete_all

    if template.allow_multiple
      response_value.each { |v| answer_values.build(template.data_type => v, answer_template_id: template.id) }
    else
      answer_values.build(template.data_type => response_value, answer_template_id: template.id)
    end

    self.save
    check_completion_from_api
  end

  def check_completion_from_api

    template_completions = []

    question.answer_templates.each do |template|
      template_answer_values = answer_values.where(answer_template_id: template.id)
      if template.parent_answer_template_id.present?
        parent_template = AnswerTemplate.find_by_id(template.parent_answer_template_id)
        parent_response_value = answer_values.where(answer_template_id: parent_template.id).collect{|rv| rv.answer_option.value }

        template_completion = parent_response_value.include?(template.parent_answer_option_value) ? template_answer_values.present? : true
      else
        template_completion = template_answer_values.present?
      end
      template_completions << template_completion
    end

    set_completion_state_from_api(template_completions)
  end

  def value
    res = {}
    answer_values.each do |av|
      res[av.answer_template.id] ||= []
      res[av.answer_template.id] << av.value
    end

    res.each_pair { |k, v| res[k] = v.first if v.length == 1 }

    res
  end

  def string_value
    res = {}
    answer_values.each do |av|
      res[av.answer_template.id.to_s] ||= []
      res[av.answer_template.id.to_s] << av.string_value
    end

    res.each_pair { |k, v| res[k] = v.first if v.length == 1 }

    res
  end

  def show_value
    if answer_values.length == 1
      answer_values.first.show_value
    else
      answer_values.map(&:show_value).join(", ")
    end
  end
  ## End Value Methods

  def complete?
    self[:state] == 'complete' or self[:state] == 'locked'
  end

  def incomplete?
    self[:state] == 'incomplete'
  end

  def locked?
    self[:state] == 'locked'
  end

  def invalid?
    self[:state] == 'invalid'
  end

  def validation_errors
    validator = AnswerValidator.new(question.slug)
    validator.messages(self)
  end

  private

  def set_completion_state(template_completions)
    validator = AnswerValidator.new(question.slug)
    validation_result = validator.validate(self)

    if preferred_not_to_answer
      self[:state] = 'complete'
    elsif validation_result[:valid] and template_completions.count > 0
      self[:state] = (template_completions.all? ? 'complete' : 'incomplete')
    else
      self[:state] = "invalid"
    end
  end

  def set_completion_state_from_api(template_completions)
    if preferred_not_to_answer
      self.update(state: 'complete')
    elsif template_completions.count > 0
      template_completions.all? ? self.update(state: 'complete') : self.update(state: 'incomplete')
    else
      self.update(state: 'invalid')
    end
  end
end
